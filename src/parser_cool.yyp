%{

// C++ stuff is
#include <stdio.h>
#include <vector>
#include <cstring>
#include <math.h>
#include <iostream>

#include "ast/ast.h"

// define line below as 1 to get debugging
#define PARSER_DEBUG 1
#define YYERROR_VERBOSE 1
extern char yytext[];

int yylex();
extern int yylineno;
int yycol = 0;

void yyerror(char const* s)
{
  fflush(stdout);
  printf("Error: line %d column %d: %s\n",yylineno,yycol,s);
}

void printDebug(const char *message){
  if(PARSER_DEBUG == 1){
    printf("Debug: %d: Parsed: %s", yylineno,message);
  }
}

%}

/* ----------- OPTIONS ------------ */
/* ----------- Union ------------ */
%union {
  int valueInt;
  char* keyword;
  char* type;
  char* valueString;
  bool  boolean;
  bake_ast::Node* node;
  bake_ast::ExprList* exprList;
}

/* --------- Base Tokens ------------ */
%token <type> TYPE
%token <type> IDENTIFIER
%token <valueInt> INTEGER
%token <valueString> STRING

/* -------- Keyword Token ----------- */
%token <keyword> CLASS
%token <keyword> INHERIT
%token <keyword> CASE
%token <keyword> ESAC
%token <keyword> IF
%token <keyword> THEN
%token <keyword> ELSE
%token <keyword> FI
%token <keyword> IN
%token <keyword> LET
%token <keyword> ISVOID
%token <keyword> NEW
%token <keyword> NOT
%token <keyword> OF
%token <keyword> WHILE
%token <keyword> LOOP
%token <keyword> POOL
%token <keyword> GOES_TO

/* ------- Compare Tokens ---------- */
%token <keyword> LARROW
%token <keyword> LEQUAL
%token <keyword> RARROW

/* ------- Boolean Tokens ---------- */
%token <boolean> TRUE
%token <boolean> FALSE

/* ------------ Types ------------- */
%type <node> class
%type <node> commandList
%type <node> command
%type <node> parameters
%type <node> declaration
%type <node> expr
%type <node> math
%type <node> compare
%type <node> callMethod
%type <node> controlFlow
%type <node> block
%type <node> cases
%type <node> declarationBlock
%type <exprList> exprList

%right LARROW
%left NOT
%nonassoc LEQUAL '=' '<'
%left '+' '-'
%left '*' '/'
%left ISVOID
%left '~'
%left '@'
%left '.'

/* ------------ RULES ------------- */
%%
root : class ';' root                                             {printDebug("class ; root\n");}
      | class ';'                                                 {printDebug("class ; \n");}

class : CLASS TYPE INHERIT TYPE '{' commandList '}'               {printDebug("class type inherit type { commandlist }\n");}
      | CLASS TYPE '{' commandList '}'                            {printDebug("class type { commandlist }\n");}
      | CLASS TYPE INHERIT TYPE '{'  '}'                          {printDebug("class type inherit type {  }\n");}
      | CLASS TYPE '{'  '}'                                       {printDebug("class type {  }\n");}

commandList : command ';'  commandList                            {printDebug("command ; commandlist\n");}
      | command ';'                                               {printDebug("command ; \n");}

command : IDENTIFIER '(' parameters ')' ':' TYPE '{' expr '}'     {printDebug("IDENTIFIER ( parameters ) : TYPE { expr }\n");}
      | IDENTIFIER '('  ')' ':' TYPE '{' expr '}'                 {printDebug("IDENTIFIER ( ) : TYPE { expr }\n");}
      | declaration                                               {printDebug("declaration\n");}

parameters : IDENTIFIER ':' TYPE                                  {printDebug("IDENTIFIER : TYPE\n");}
      | IDENTIFIER ':' TYPE ',' parameters                        {printDebug("IDENTIFIER : TYPE , parameters\n");}

expr : NEW TYPE                                                   {printDebug("NEW TYPE\n");}
      | IDENTIFIER LARROW expr                                    {printDebug("IDENTIFIER <- expr\n");}
      | LET declarationBlock IN expr                              {printDebug("LET declarationBlock IN expr\n");}
      | math                                                      {printDebug("math\n");}
      | compare                                                   {printDebug("compare\n");}
      | callMethod                                                {printDebug("callMethod\n");}
      | controlFlow                                               {printDebug("controlFlow\n");}
      | '{' block '}'                                             {printDebug("{ block }\n");}
      | IDENTIFIER                                                {printDebug("IDENTIFIER\n");}
      | INTEGER                                                   {printDebug("INTEGER\n");}
| STRING                                                    {printDebug("STRING\n"); $$ = new bake_ast::StringVal($1);}
      | TRUE                                                      {printDebug(" true \n");}
      | FALSE                                                     {printDebug(" false \n"); }

controlFlow: IF expr THEN expr ELSE expr FI                       {printDebug(" IF expr THEN expr ELSE expr FI\n");}
      | WHILE expr LOOP expr                                      {printDebug("WHILE expr LOOP expr\n");}
      | CASE expr OF cases ESAC                                   {printDebug("CASE expr OF cases ESAC\n");}

cases : IDENTIFIER ':' TYPE GOES_TO expr ','                      {printDebug("IDENTIFIER : TYPE => expr , \n");}
      | IDENTIFIER ':' TYPE GOES_TO expr ',' cases                {printDebug("IDENTIFIER : TYPE => expr, cases \n");}

math : expr '/' expr                                              {printDebug("/\n");}
      | expr '+' expr                                             {printDebug("+\n");}
      | expr '-' expr                                             {printDebug("-\n");}
      | expr '*' expr                                             {printDebug("*\n");}
      | '(' expr ')'                                              {printDebug("()\n");}
      | '~' expr                                                  {printDebug("~\n");}

compare : ISVOID expr                                             {printDebug("ISVOID\n");}
      | expr '<' expr                                             {printDebug("<\n");}
      | expr LEQUAL expr                                          {printDebug("<=\n");}
      | expr '=' expr                                             {printDebug("=\n");}
      | NOT expr                                                  {printDebug("NOT\n");}

callMethod : expr '.' IDENTIFIER '(' exprList ')'                 {printDebug("expr.IDENTIFIER(exprList)\n");}
      | expr '@' TYPE '.' IDENTIFIER '(' exprList ')'             {printDebug("expr@TYPE.IDENTIFIER(exprList)\n" );}
      | expr '.' IDENTIFIER '(' ')'                               {printDebug("expr.IDENTIFIER()\n");}
      | expr '@' TYPE '.' IDENTIFIER '(' ')'                      {printDebug("expr@TYPE.IDENTIFIER(exprList)\n" );}
      | IDENTIFIER '(' exprList ')'                               {printDebug("IDENTIFIER (exprList)\n");}
      | IDENTIFIER '(' ')'                                        {printDebug("IDENTIFIER ( )\n" );}

declaration : IDENTIFIER ':' TYPE                                 {printDebug("IDENTIFIER : TYPE\n");}
      | IDENTIFIER ':' TYPE LARROW expr                           {printDebug("IDENTIFIER : TYPE <- expr\n");}

declarationBlock : declaration ',' declarationBlock               {printDebug("declaration , declarationBlock\n");}
      | declaration                                               {printDebug("declaration\n");}

block : expr ';'  block                                           {printDebug("expr ; block\n") ; }
      | expr ';'                                                  {printDebug("expr ;\n");}

exprList : expr ',' exprList                                      {printDebug("expr ; exprList\n"); /*$3->add($1); $$ = $3;*/}
      | expr                                                      {
                                                                    printDebug("expr\n");
                                                                    //$$ = new ExprList(); $$->add($1);
                                                                  }
%%
