%{

// C++ stuff is
#include <stdio.h>
#include <vector>
#include <cstring>
#include <math.h>
#include <iostream>

#include "ast/ast.h"

// define line below as 1 to get debugging
#define PARSER_DEBUG 1
#define YYERROR_VERBOSE 1
extern char yytext[];

int yylex();
extern int yylineno;
int yycol = 0;

void yyerror(char const* s)
{
  fflush(stdout);
  printf("Error: line %d column %d: %s\n",yylineno,yycol,s);
}

void printDebug(const char *message){
  if(PARSER_DEBUG == 1){
    printf("Debug: %d: Parsed: %s", yylineno,message);
  }
}

%}

/* ----------- OPTIONS ------------ */
/* ----------- Union ------------ */
%union {
  int valueInt;
  char* keyword;
  char* type;
  char* valueString;
  bool  boolean;
  bake_ast::Node* node;
  bake_ast::ExprList* exprList;
}

/* --------- Base Tokens ------------ */
%token <type> TYPE
%token <type> IDENTIFIER
%token <valueInt> INTEGER
%token <valueString> STRING

/* -------- Keyword Token ----------- */
%token <keyword> CLASS
%token <keyword> INHERIT
%token <keyword> CASE
%token <keyword> ESAC
%token <keyword> IF
%token <keyword> THEN
%token <keyword> ELSE
%token <keyword> FI
%token <keyword> IN
%token <keyword> LET
%token <keyword> ISVOID
%token <keyword> NEW
%token <keyword> NOT
%token <keyword> OF
%token <keyword> WHILE
%token <keyword> LOOP
%token <keyword> POOL
%token <keyword> GOES_TO

/* ------- Compare Tokens ---------- */
%token <keyword> LARROW
%token <keyword> LEQUAL
%token <keyword> RARROW

/* ------- Boolean Tokens ---------- */
%token <boolean> TRUE
%token <boolean> FALSE

/* ------------ Types ------------- */
%type <node> class
%type <node> commandList
%type <node> command
%type <node> parameters
%type <node> declaration
%type <node> expr
%type <node> math
%type <node> compare
%type <node> callMethod
%type <node> controlFlow
%type <node> block
%type <node> cases
%type <node> declarationBlock
%type <exprList> exprList

%right LARROW
%left NOT
%nonassoc LEQUAL '=' '<'
%left '+' '-'
%left '*' '/'
%left ISVOID
%left '~'
%left '@'
%left '.'

/* ------------ RULES ------------- */
%%
root : class ';' root                                             {printDebug("class ; root\n"); $3->add($1); $$ = $3;}
      | class ';'                                                 {printDebug("class ; \n"); $$ = new bake_ast::ClassList(); $$->add($1);}

class : CLASS TYPE INHERIT TYPE '{' commandList '}'               {printDebug("class type inherit type { commandlist }\n");
                                                                    $$ = new bake_ast::ClassStatement($2, $4, $6);}
      | CLASS TYPE '{' commandList '}'                            {printDebug("class type { commandlist }\n");
                                                                    $$ = new bake_ast::ClassStatement($2, nullptr, $4);}
      | CLASS TYPE INHERIT TYPE '{'  '}'                          {printDebug("class type inherit type {  }\n");
                                                                    $$ = new bake_ast::ClassStatement($2, $4);}
      | CLASS TYPE '{'  '}'                                       {printDebug("class type {  }\n");
                                                                    $$ = new bake_ast::ClassStatement($2);}

/*List of methods/assignments*/
commandList : command ';'  commandList                            {printDebug("command ; commandlist\n");}
      | command ';'                                               {printDebug("command ; \n");}

/*Method/var declaration*/
command : IDENTIFIER '(' parameters ')' ':' TYPE '{' expr '}'     {printDebug("IDENTIFIER ( parameters ) : TYPE { expr }\n");}
      | IDENTIFIER '('  ')' ':' TYPE '{' expr '}'                 {printDebug("IDENTIFIER ( ) : TYPE { expr }\n");}
      | declaration                                               {printDebug("declaration\n");}

/*FormalDeclare, ListFormalDeclare w/out 3rd param*/
parameters : IDENTIFIER ':' TYPE                                  {printDebug("IDENTIFIER : TYPE\n");}
      | IDENTIFIER ':' TYPE ',' parameters                        {printDebug("IDENTIFIER : TYPE , parameters\n");}

expr : NEW TYPE                                                   {printDebug("NEW TYPE\n"); $$ = new bake_ast::New($2);}
      | IDENTIFIER LARROW expr                                    {printDebug("IDENTIFIER <- expr\n");
                                                                    $$ = new bake_ast::Assign($1, $3);}
      | LET declarationBlock IN expr                              {printDebug("LET declarationBlock IN expr\n");/*Let <- ListformalDeclre, Node* */}
      | math                                                      {printDebug("math\n"); $$ = $1;}
      | compare                                                   {printDebug("compare\n"); $$ = $1;}
      | callMethod                                                {printDebug("callMethod\n"); $$ = $1;}
      | controlFlow                                               {printDebug("controlFlow\n"); $$ = $1;}
      | '{' block '}'                                             {printDebug("{ block }\n"); $$ = $2;}
      | IDENTIFIER                                                {printDebug("IDENTIFIER\n"); $$ = new bake_ast::Id($1);}
      | INTEGER                                                   {printDebug("INTEGER\n"); $$ = new bake_ast::IntegerVal($1);}
      | STRING                                                    {printDebug("STRING\n"); $$ = new bake_ast::StringVal($1);}
      | TRUE                                                      {printDebug(" true \n"); $$ = new bake_ast::BoolVal($1);}
      | FALSE                                                     {printDebug(" false \n"); $$ = new bake_ast::BoolVal($1);}

controlFlow: IF expr THEN expr ELSE expr FI                       {printDebug(" IF expr THEN expr ELSE expr FI\n");
                                                                    $$ = new bake_ast::IfStatement($2, $4, $6);}
      | WHILE expr LOOP expr                                      {printDebug("WHILE expr LOOP expr\n");
                                                                    $$ = new bake_ast::WhileLoop($2, $4);}
      | CASE expr OF cases ESAC                                   {printDebug("CASE expr OF cases ESAC\n");
                                                                    $$ = new bake_ast::ClassStatement($2, $4);}

cases : IDENTIFIER ':' TYPE GOES_TO expr ','                      {printDebug("IDENTIFIER : TYPE => expr , \n");
                                                                    $$ = new bake_ast::CaseList();
                                                                    $$->add(new bake_ast::Case($1, $3, $5));}
      | IDENTIFIER ':' TYPE GOES_TO expr ',' cases                {printDebug("IDENTIFIER : TYPE => expr, cases \n");
                                                                    $7->add(new bake_ast::Case($1, $3, $5)); $$ = $7;}

math : expr '/' expr                                              {printDebug("/\n"); $$ = new bake_ast::Divide($1, $3);}
      | expr '+' expr                                             {printDebug("+\n"); $$ = new bake_ast::Plus($1, $3);}
      | expr '-' expr                                             {printDebug("-\n"); $$ = new bake_ast::Minus($1, $3);}
      | expr '*' expr                                             {printDebug("*\n"); $$ = new bake_ast::Multiply($1, $3);}
      | '(' expr ')'                                              {printDebug("()\n"); $$ = $2;}
      | '~' expr                                                  {printDebug("~\n"); $$ = new bake_ast::BitNot($2);}

compare : ISVOID expr                                             {printDebug("ISVOID\n"); $$ = new bake_ast::Isvoid($2);}
      | expr '<' expr                                             {printDebug("<\n"); $$ = new bake_ast::LessThan($1, $3);}
      | expr LEQUAL expr                                          {printDebug("<=\n"); $$ = new bake_ast::LessThanEqual($1, $3);}
      | expr '=' expr                                             {printDebug("=\n"); $$ = new bake_ast::Equal($1, $3);}
      | NOT expr                                                  {printDebug("NOT\n"); $$ = new bake_ast::LogicalNot($2);}

callMethod : expr '.' IDENTIFIER '(' exprList ')'                 {printDebug("expr.IDENTIFIER(exprList)\n");
                                                                    $$ = new bake_ast::Dispatch($1, nullptr, $3, $5);}
      | expr '@' TYPE '.' IDENTIFIER '(' exprList ')'             {printDebug("expr@TYPE.IDENTIFIER(exprList)\n" );
                                                                    $$ = new bake_ast::Dispatch($1, $3, $5, $7);}
      | expr '.' IDENTIFIER '(' ')'                               {printDebug("expr.IDENTIFIER()\n");
                                                                    $$ = new bake_ast::Dispatch($1, nullptr, $5, nullptr);}
      | expr '@' TYPE '.' IDENTIFIER '(' ')'                      {printDebug("expr@TYPE.IDENTIFIER(exprList)\n" );
                                                                    $$ = new bake_ast::Dispatch($1, $3, $5, nullptr);}
      | IDENTIFIER '(' exprList ')'                               {printDebug("IDENTIFIER (exprList)\n");
                                                                    $$ = new bake_ast::Dispatch(nullptr, nullptr, $1, $3);}
      | IDENTIFIER '(' ')'                                        {printDebug("IDENTIFIER ( )\n" );
                                                                    $$ = new bake_ast::Dispatch(nullptr, nullptr, $1, nullptr);}

/*FormalDeclare*/
declaration : IDENTIFIER ':' TYPE                                 {printDebug("IDENTIFIER : TYPE\n");}
      | IDENTIFIER ':' TYPE LARROW expr                           {printDebug("IDENTIFIER : TYPE <- expr\n");}

/*ListFormalDeclare*/
declarationBlock : declaration ',' declarationBlock               {printDebug("declaration , declarationBlock\n");}
      | declaration                                               {printDebug("declaration\n");}

block : expr ';'  block                                           {printDebug("expr ; block\n"); $3->add($1); $$ = $3;}
      | expr ';'                                                  {printDebug("expr ;\n"); $$ = new ExprList(); $$->add($1);}

exprList : expr ',' exprList                                      {printDebug("expr ; exprList\n"); $3->add($1); $$ = $3;}
      | expr                                                      {printDebug("expr\n"); $$ = new ExprList(); $$->add($1);}
%%
